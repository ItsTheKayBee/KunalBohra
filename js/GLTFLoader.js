THREE.GLTFLoader = function () { function e(e) { THREE.Loader.call(this, e), this.dracoLoader = null, this.ddsLoader = null } function t() { var e = {}; return { get: function (t) { return e[t] }, add: function (t, r) { e[t] = r }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } e.prototype = Object.assign(Object.create(THREE.Loader.prototype), { constructor: e, load: function (e, t, r, a) { var s, n = this; s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : THREE.LoaderUtils.extractUrlBase(e), n.manager.itemStart(e); var o = function (t) { a ? a(t) : console.error(t), n.manager.itemError(e), n.manager.itemEnd(e) }, i = new THREE.FileLoader(n.manager); i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), "use-credentials" === n.crossOrigin && i.setWithCredentials(!0), i.load(e, function (r) { try { n.parse(r, s, function (r) { t(r), n.manager.itemEnd(e) }, o) } catch (e) { o(e) } }, r, o) }, setDRACOLoader: function (e) { return this.dracoLoader = e, this }, setDDSLoader: function (e) { return this.ddsLoader = e, this }, parse: function (e, t, l, c) { var d, E = {}; if ("string" == typeof e) d = e; else if (THREE.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === i) { try { E[r.KHR_BINARY_GLTF] = new u(e) } catch (e) { return void (c && c(e)) } d = E[r.KHR_BINARY_GLTF].content } else d = THREE.LoaderUtils.decodeText(new Uint8Array(e)); var g = JSON.parse(d); if (void 0 === g.asset || g.asset.version[0] < 2) c && c(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); else { if (g.extensionsUsed) for (var T = 0; T < g.extensionsUsed.length; ++T) { var v = g.extensionsUsed[T], R = g.extensionsRequired || []; switch (v) { case r.KHR_LIGHTS_PUNCTUAL: E[v] = new s(g); break; case r.KHR_MATERIALS_CLEARCOAT: E[v] = new o; break; case r.KHR_MATERIALS_UNLIT: E[v] = new n; break; case r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: E[v] = new m; break; case r.KHR_DRACO_MESH_COMPRESSION: E[v] = new p(g, this.dracoLoader); break; case r.MSFT_TEXTURE_DDS: E[v] = new a(this.ddsLoader); break; case r.KHR_TEXTURE_TRANSFORM: E[v] = new h; break; case r.KHR_MESH_QUANTIZATION: E[v] = new f; break; default: R.indexOf(v) >= 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + v + '".') } } var M = new B(g, E, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, manager: this.manager }); M.fileLoader.setRequestHeader(this.requestHeader), M.parse(l, c) } } }); var r = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", MSFT_TEXTURE_DDS: "MSFT_texture_dds" }; function a(e) { if (!e) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader"); this.name = r.MSFT_TEXTURE_DDS, this.ddsLoader = e } function s(e) { this.name = r.KHR_LIGHTS_PUNCTUAL; var t = e.extensions && e.extensions[r.KHR_LIGHTS_PUNCTUAL] || {}; this.lightDefs = t.lights || [] } function n() { this.name = r.KHR_MATERIALS_UNLIT } function o() { this.name = r.KHR_MATERIALS_CLEARCOAT } s.prototype.loadLight = function (e) { var t, r = this.lightDefs[e], a = new THREE.Color(16777215); void 0 !== r.color && a.fromArray(r.color); var s = void 0 !== r.range ? r.range : 0; switch (r.type) { case "directional": (t = new THREE.DirectionalLight(a)).target.position.set(0, 0, -1), t.add(t.target); break; case "point": (t = new THREE.PointLight(a)).distance = s; break; case "spot": (t = new THREE.SpotLight(a)).distance = s, r.spot = r.spot || {}, r.spot.innerConeAngle = void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0, r.spot.outerConeAngle = void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4, t.angle = r.spot.outerConeAngle, t.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle, t.target.position.set(0, 0, -1), t.add(t.target); break; default: throw new Error('THREE.GLTFLoader: Unexpected light type, "' + r.type + '".') }return t.position.set(0, 0, 0), t.decay = 2, void 0 !== r.intensity && (t.intensity = r.intensity), t.name = r.name || "light_" + e, Promise.resolve(t) }, n.prototype.getMaterialType = function () { return THREE.MeshBasicMaterial }, n.prototype.extendParams = function (e, t, r) { var a = []; e.color = new THREE.Color(1, 1, 1), e.opacity = 1; var s = t.pbrMetallicRoughness; if (s) { if (Array.isArray(s.baseColorFactor)) { var n = s.baseColorFactor; e.color.fromArray(n), e.opacity = n[3] } void 0 !== s.baseColorTexture && a.push(r.assignTexture(e, "map", s.baseColorTexture)) } return Promise.all(a) }, o.prototype.getMaterialType = function () { return THREE.MeshPhysicalMaterial }, o.prototype.extendParams = function (e, t, r) { var a = [], s = t.extensions[this.name]; if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && a.push(r.assignTexture(e, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && a.push(r.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (a.push(r.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) { var n = s.clearcoatNormalTexture.scale; e.clearcoatNormalScale = new THREE.Vector2(n, n) } return Promise.all(a) }; var i = "glTF", l = 12, c = { JSON: 1313821514, BIN: 5130562 }; function u(e) { this.name = r.KHR_BINARY_GLTF, this.content = null, this.body = null; var t = new DataView(e, 0, l); if (this.header = { magic: THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== i) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); for (var a = new DataView(e, l), s = 0; s < a.byteLength;) { var n = a.getUint32(s, !0); s += 4; var o = a.getUint32(s, !0); if (s += 4, o === c.JSON) { var u = new Uint8Array(e, l + s, n); this.content = THREE.LoaderUtils.decodeText(u) } else if (o === c.BIN) { var p = l + s; this.body = e.slice(p, p + n) } s += n } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } function p(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = r.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } function h() { this.name = r.KHR_TEXTURE_TRANSFORM } function d(e) { THREE.MeshStandardMaterial.call(this), this.isGLTFSpecularGlossinessMaterial = !0; var t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), r = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), a = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), n = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n"), o = { specular: { value: (new THREE.Color).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = o, this.onBeforeCompile = function (e) { for (var i in o) e.uniforms[i] = o[i]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;"), e.fragmentShader = e.fragmentShader.replace("uniform float metalness;", "uniform float glossiness;"), e.fragmentShader = e.fragmentShader.replace("#include <roughnessmap_pars_fragment>", t), e.fragmentShader = e.fragmentShader.replace("#include <metalnessmap_pars_fragment>", r), e.fragmentShader = e.fragmentShader.replace("#include <roughnessmap_fragment>", a), e.fragmentShader = e.fragmentShader.replace("#include <metalnessmap_fragment>", s), e.fragmentShader = e.fragmentShader.replace("#include <lights_physical_fragment>", n) }, Object.defineProperties(this, { specular: { get: function () { return o.specular.value }, set: function (e) { o.specular.value = e } }, specularMap: { get: function () { return o.specularMap.value }, set: function (e) { o.specularMap.value = e } }, glossiness: { get: function () { return o.glossiness.value }, set: function (e) { o.glossiness.value = e } }, glossinessMap: { get: function () { return o.glossinessMap.value }, set: function (e) { o.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_ROUGHNESSMAP = "") : (delete this.defines.USE_ROUGHNESSMAP, delete this.defines.USE_GLOSSINESSMAP) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } function m() { return { name: r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function () { return d }, extendParams: function (e, t, r) { var a = t.extensions[this.name]; e.color = new THREE.Color(1, 1, 1), e.opacity = 1; var s = []; if (Array.isArray(a.diffuseFactor)) { var n = a.diffuseFactor; e.color.fromArray(n), e.opacity = n[3] } if (void 0 !== a.diffuseTexture && s.push(r.assignTexture(e, "map", a.diffuseTexture)), e.emissive = new THREE.Color(0, 0, 0), e.glossiness = void 0 !== a.glossinessFactor ? a.glossinessFactor : 1, e.specular = new THREE.Color(1, 1, 1), Array.isArray(a.specularFactor) && e.specular.fromArray(a.specularFactor), void 0 !== a.specularGlossinessTexture) { var o = a.specularGlossinessTexture; s.push(r.assignTexture(e, "glossinessMap", o)), s.push(r.assignTexture(e, "specularMap", o)) } return Promise.all(s) }, createMaterial: function (e) { var t = new d(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = THREE.TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } } function f() { this.name = r.KHR_MESH_QUANTIZATION } function E(e, t, r, a) { THREE.Interpolant.call(this, e, t, r, a) } p.prototype.decodePrimitive = function (e, t) { var r = this.json, a = this.dracoLoader, s = e.extensions[this.name].bufferView, n = e.extensions[this.name].attributes, o = {}, i = {}, l = {}; for (var c in n) { var u = _[c] || c.toLowerCase(); o[u] = n[c] } for (c in e.attributes) { u = _[c] || c.toLowerCase(); if (void 0 !== n[c]) { var p = r.accessors[e.attributes[c]], h = H[p.componentType]; l[u] = h, i[u] = !0 === p.normalized } } return t.getDependency("bufferView", s).then(function (e) { return new Promise(function (t) { a.decodeDracoFile(e, function (e) { for (var r in e.attributes) { var a = e.attributes[r], s = i[r]; void 0 !== s && (a.normalized = s) } t(e) }, o, l) }) }) }, h.prototype.extendTexture = function (e, t) { return e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e.needsUpdate = !0, e }, d.prototype = Object.create(THREE.MeshStandardMaterial.prototype), d.prototype.constructor = d, d.prototype.copy = function (e) { return THREE.MeshStandardMaterial.prototype.copy.call(this, e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }, E.prototype = Object.create(THREE.Interpolant.prototype), E.prototype.constructor = E, E.prototype.copySampleValue_ = function (e) { for (var t = this.resultBuffer, r = this.sampleValues, a = this.valueSize, s = e * a * 3 + a, n = 0; n !== a; n++)t[n] = r[s + n]; return t }, E.prototype.beforeStart_ = E.prototype.copySampleValue_, E.prototype.afterEnd_ = E.prototype.copySampleValue_, E.prototype.interpolate_ = function (e, t, r, a) { for (var s = this.resultBuffer, n = this.sampleValues, o = this.valueSize, i = 2 * o, l = 3 * o, c = a - t, u = (r - t) / c, p = u * u, h = p * u, d = e * l, m = d - l, f = -2 * h + 3 * p, E = h - p, g = 1 - f, T = E - p + u, v = 0; v !== o; v++) { var R = n[m + v + o], M = n[m + v + i] * c, y = n[d + v + o], S = n[d + v] * c; s[v] = g * R + T * M + f * y + E * S } return s }; var g = 0, T = 1, v = 2, R = 3, M = 4, y = 5, S = 6, H = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, L = { 9728: THREE.NearestFilter, 9729: THREE.LinearFilter, 9984: THREE.NearestMipmapNearestFilter, 9985: THREE.LinearMipmapNearestFilter, 9986: THREE.NearestMipmapLinearFilter, 9987: THREE.LinearMipmapLinearFilter }, x = { 33071: THREE.ClampToEdgeWrapping, 33648: THREE.MirroredRepeatWrapping, 10497: THREE.RepeatWrapping }, A = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, _ = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, w = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, b = { CUBICSPLINE: void 0, LINEAR: THREE.InterpolateLinear, STEP: THREE.InterpolateDiscrete }, I = "OPAQUE", P = "MASK", C = "BLEND", F = { "image/png": THREE.RGBAFormat, "image/jpeg": THREE.RGBFormat }; function O(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) ? e : /^data:.*,.*$/i.test(e) ? e : /^blob:.*$/i.test(e) ? e : t + e) } function N(e, t, r) { for (var a in r.extensions) void 0 === e[a] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[a] = r.extensions[a]) } function U(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function D(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (var r = 0, a = t.weights.length; r < a; r++)e.morphTargetInfluences[r] = t.weights[r]; if (t.extras && Array.isArray(t.extras.targetNames)) { var s = t.extras.targetNames; if (e.morphTargetInfluences.length === s.length) { e.morphTargetDictionary = {}; for (r = 0, a = s.length; r < a; r++)e.morphTargetDictionary[s[r]] = r } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function G(e) { for (var t = "", r = Object.keys(e).sort(), a = 0, s = r.length; a < s; a++)t += r[a] + ":" + e[r[a]] + ";"; return t } function B(e, r, a) { this.json = e || {}, this.extensions = r || {}, this.options = a || {}, this.cache = new t, this.associations = new Map, this.primitiveCache = {}, this.textureLoader = new THREE.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new THREE.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } function k(e, t, r) { var a = t.attributes, s = []; function n(t, a) { return r.getDependency("accessor", t).then(function (t) { e.setAttribute(a, t) }) } for (var o in a) { var i = _[o] || o.toLowerCase(); i in e.attributes || s.push(n(a[o], i)) } if (void 0 !== t.indices && !e.index) { var l = r.getDependency("accessor", t.indices).then(function (t) { e.setIndex(t) }); s.push(l) } return U(e, t), function (e, t, r) { var a = t.attributes, s = new THREE.Box3; if (void 0 !== a.POSITION) { var n = (h = r.json.accessors[a.POSITION]).min, o = h.max; if (void 0 !== n && void 0 !== o) { s.set(new THREE.Vector3(n[0], n[1], n[2]), new THREE.Vector3(o[0], o[1], o[2])); var i = t.targets; if (void 0 !== i) { for (var l = new THREE.Vector3, c = new THREE.Vector3, u = 0, p = i.length; u < p; u++) { var h, d = i[u]; if (void 0 !== d.POSITION) n = (h = r.json.accessors[d.POSITION]).min, o = h.max, void 0 !== n && void 0 !== o ? (c.setX(Math.max(Math.abs(n[0]), Math.abs(o[0]))), c.setY(Math.max(Math.abs(n[1]), Math.abs(o[1]))), c.setZ(Math.max(Math.abs(n[2]), Math.abs(o[2]))), l.max(c)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } s.expandByVector(l) } e.boundingBox = s; var m = new THREE.Sphere; s.getCenter(m.center), m.radius = s.min.distanceTo(s.max) / 2, e.boundingSphere = m } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } }(e, t, r), Promise.all(s).then(function () { return void 0 !== t.targets ? function (e, t, r) { for (var a = !1, s = !1, n = 0, o = t.length; n < o && (void 0 !== (c = t[n]).POSITION && (a = !0), void 0 !== c.NORMAL && (s = !0), !a || !s); n++); if (!a && !s) return Promise.resolve(e); var i = [], l = []; for (n = 0, o = t.length; n < o; n++) { var c = t[n]; if (a) { var u = void 0 !== c.POSITION ? r.getDependency("accessor", c.POSITION) : e.attributes.position; i.push(u) } s && (u = void 0 !== c.NORMAL ? r.getDependency("accessor", c.NORMAL) : e.attributes.normal, l.push(u)) } return Promise.all([Promise.all(i), Promise.all(l)]).then(function (t) { var r = t[0], n = t[1]; return a && (e.morphAttributes.position = r), s && (e.morphAttributes.normal = n), e.morphTargetsRelative = !0, e }) }(e, t.targets, r) : e }) } function K(e, t) { var r = e.getIndex(); if (null === r) { var a = [], s = e.getAttribute("position"); if (void 0 === s) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (var n = 0; n < s.count; n++)a.push(n); e.setIndex(a), r = e.getIndex() } var o = r.count - 2, i = []; if (t === THREE.TriangleFanDrawMode) for (n = 1; n <= o; n++)i.push(r.getX(0)), i.push(r.getX(n)), i.push(r.getX(n + 1)); else for (n = 0; n < o; n++)n % 2 == 0 ? (i.push(r.getX(n)), i.push(r.getX(n + 1)), i.push(r.getX(n + 2))) : (i.push(r.getX(n + 2)), i.push(r.getX(n + 1)), i.push(r.getX(n))); i.length / 3 !== o && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); var l = e.clone(); return l.setIndex(i), l } return B.prototype.parse = function (e, t) { var r = this, a = this.json, s = this.extensions; this.cache.removeAll(), this.markDefs(), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then(function (t) { var n = { scene: t[0][a.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: a.asset, parser: r, userData: {} }; N(s, n, a), U(n, a), e(n) }).catch(t) }, B.prototype.markDefs = function () { for (var e = this.json.nodes || [], t = this.json.skins || [], r = this.json.meshes || [], a = {}, s = {}, n = 0, o = t.length; n < o; n++)for (var i = t[n].joints, l = 0, c = i.length; l < c; l++)e[i[l]].isBone = !0; for (var u = 0, p = e.length; u < p; u++) { var h = e[u]; void 0 !== h.mesh && (void 0 === a[h.mesh] && (a[h.mesh] = s[h.mesh] = 0), a[h.mesh]++, void 0 !== h.skin && (r[h.mesh].isSkinnedMesh = !0)) } this.json.meshReferences = a, this.json.meshUses = s }, B.prototype.getDependency = function (e, t) { var a = e + ":" + t, s = this.cache.get(a); if (!s) { switch (e) { case "scene": s = this.loadScene(t); break; case "node": s = this.loadNode(t); break; case "mesh": s = this.loadMesh(t); break; case "accessor": s = this.loadAccessor(t); break; case "bufferView": s = this.loadBufferView(t); break; case "buffer": s = this.loadBuffer(t); break; case "material": s = this.loadMaterial(t); break; case "texture": s = this.loadTexture(t); break; case "skin": s = this.loadSkin(t); break; case "animation": s = this.loadAnimation(t); break; case "camera": s = this.loadCamera(t); break; case "light": s = this.extensions[r.KHR_LIGHTS_PUNCTUAL].loadLight(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(a, s) } return s }, B.prototype.getDependencies = function (e) { var t = this.cache.get(e); if (!t) { var r = this, a = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(a.map(function (t, a) { return r.getDependency(e, a) })), this.cache.add(e, t) } return t }, B.prototype.loadBuffer = function (e) { var t = this.json.buffers[e], a = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[r.KHR_BINARY_GLTF].body); var s = this.options; return new Promise(function (e, r) { a.load(O(t.uri, s.path), e, void 0, function () { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) }, B.prototype.loadBufferView = function (e) { var t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function (e) { var r = t.byteLength || 0, a = t.byteOffset || 0; return e.slice(a, a + r) }) }, B.prototype.loadAccessor = function (e) { var t = this, r = this.json, a = this.json.accessors[e]; if (void 0 === a.bufferView && void 0 === a.sparse) return Promise.resolve(null); var s = []; return void 0 !== a.bufferView ? s.push(this.getDependency("bufferView", a.bufferView)) : s.push(null), void 0 !== a.sparse && (s.push(this.getDependency("bufferView", a.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", a.sparse.values.bufferView))), Promise.all(s).then(function (e) { var s, n, o = e[0], i = A[a.type], l = H[a.componentType], c = l.BYTES_PER_ELEMENT, u = c * i, p = a.byteOffset || 0, h = void 0 !== a.bufferView ? r.bufferViews[a.bufferView].byteStride : void 0, d = !0 === a.normalized; if (h && h !== u) { var m = Math.floor(p / h), f = "InterleavedBuffer:" + a.bufferView + ":" + a.componentType + ":" + m + ":" + a.count, E = t.cache.get(f); E || (s = new l(o, m * h, a.count * h / c), E = new THREE.InterleavedBuffer(s, h / c), t.cache.add(f, E)), n = new THREE.InterleavedBufferAttribute(E, i, p % h / c, d) } else s = null === o ? new l(a.count * i) : new l(o, p, a.count * i), n = new THREE.BufferAttribute(s, i, d); if (void 0 !== a.sparse) { var g = A.SCALAR, T = H[a.sparse.indices.componentType], v = a.sparse.indices.byteOffset || 0, R = a.sparse.values.byteOffset || 0, M = new T(e[1], v, a.sparse.count * g), y = new l(e[2], R, a.sparse.count * i); null !== o && (n = new THREE.BufferAttribute(n.array.slice(), n.itemSize, n.normalized)); for (var S = 0, L = M.length; S < L; S++) { var x = M[S]; if (n.setX(x, y[S * i]), i >= 2 && n.setY(x, y[S * i + 1]), i >= 3 && n.setZ(x, y[S * i + 2]), i >= 4 && n.setW(x, y[S * i + 3]), i >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return n }) }, B.prototype.loadTexture = function (e) { var t, a = this, s = this.json, n = this.options, o = this.textureLoader, i = self.URL || self.webkitURL, l = s.textures[e], c = l.extensions || {}, u = (t = c[r.MSFT_TEXTURE_DDS] ? s.images[c[r.MSFT_TEXTURE_DDS].source] : s.images[l.source]).uri, p = !1; return void 0 !== t.bufferView && (u = a.getDependency("bufferView", t.bufferView).then(function (e) { p = !0; var r = new Blob([e], { type: t.mimeType }); return u = i.createObjectURL(r) })), Promise.resolve(u).then(function (e) { var t = n.manager.getHandler(e); return t || (t = c[r.MSFT_TEXTURE_DDS] ? a.extensions[r.MSFT_TEXTURE_DDS].ddsLoader : o), new Promise(function (r, a) { t.load(O(e, n.path), r, void 0, a) }) }).then(function (r) { !0 === p && i.revokeObjectURL(u), r.flipY = !1, l.name && (r.name = l.name), t.mimeType in F && (r.format = F[t.mimeType]); var n = (s.samplers || {})[l.sampler] || {}; return r.magFilter = L[n.magFilter] || THREE.LinearFilter, r.minFilter = L[n.minFilter] || THREE.LinearMipmapLinearFilter, r.wrapS = x[n.wrapS] || THREE.RepeatWrapping, r.wrapT = x[n.wrapT] || THREE.RepeatWrapping, a.associations.set(r, { type: "textures", index: e }), r }) }, B.prototype.assignTexture = function (e, t, a) { var s = this; return this.getDependency("texture", a.index).then(function (n) { if (!n.isCompressedTexture) switch (t) { case "aoMap": case "emissiveMap": case "metalnessMap": case "normalMap": case "roughnessMap": n.format = THREE.RGBFormat }if (void 0 === a.texCoord || 0 == a.texCoord || "aoMap" === t && 1 == a.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + a.texCoord + " for texture " + t + " not yet supported."), s.extensions[r.KHR_TEXTURE_TRANSFORM]) { var o = void 0 !== a.extensions ? a.extensions[r.KHR_TEXTURE_TRANSFORM] : void 0; if (o) { var i = s.associations.get(n); n = s.extensions[r.KHR_TEXTURE_TRANSFORM].extendTexture(n, o), s.associations.set(n, i) } } e[t] = n }) }, B.prototype.assignFinalMaterial = function (e) { var t = e.geometry, r = e.material, a = void 0 !== t.attributes.tangent, s = void 0 !== t.attributes.color, n = void 0 === t.attributes.normal, o = !0 === e.isSkinnedMesh, i = Object.keys(t.morphAttributes).length > 0, l = i && void 0 !== t.morphAttributes.normal; if (e.isPoints) { var c = "PointsMaterial:" + r.uuid, u = this.cache.get(c); u || (u = new THREE.PointsMaterial, THREE.Material.prototype.copy.call(u, r), u.color.copy(r.color), u.map = r.map, u.sizeAttenuation = !1, this.cache.add(c, u)), r = u } else if (e.isLine) { c = "LineBasicMaterial:" + r.uuid; var p = this.cache.get(c); p || (p = new THREE.LineBasicMaterial, THREE.Material.prototype.copy.call(p, r), p.color.copy(r.color), this.cache.add(c, p)), r = p } if (a || s || n || o || i) { c = "ClonedMaterial:" + r.uuid + ":"; r.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"), o && (c += "skinning:"), a && (c += "vertex-tangents:"), s && (c += "vertex-colors:"), n && (c += "flat-shading:"), i && (c += "morph-targets:"), l && (c += "morph-normals:"); var h = this.cache.get(c); h || (h = r.clone(), o && (h.skinning = !0), a && (h.vertexTangents = !0), s && (h.vertexColors = !0), n && (h.flatShading = !0), i && (h.morphTargets = !0), l && (h.morphNormals = !0), this.cache.add(c, h), this.associations.set(h, this.associations.get(r))), r = h } r.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), r.normalScale && !a && (r.normalScale.y = -r.normalScale.y), r.clearcoatNormalScale && !a && (r.clearcoatNormalScale.y = -r.clearcoatNormalScale.y), e.material = r }, B.prototype.loadMaterial = function (e) { var t, a = this, s = this.json, n = this.extensions, o = s.materials[e], i = {}, l = o.extensions || {}, c = []; if (l[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { var u = n[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; t = u.getMaterialType(), c.push(u.extendParams(i, o, a)) } else if (l[r.KHR_MATERIALS_UNLIT]) { var p = n[r.KHR_MATERIALS_UNLIT]; t = p.getMaterialType(), c.push(p.extendParams(i, o, a)) } else { t = THREE.MeshStandardMaterial; var h = o.pbrMetallicRoughness || {}; if (i.color = new THREE.Color(1, 1, 1), i.opacity = 1, Array.isArray(h.baseColorFactor)) { var m = h.baseColorFactor; i.color.fromArray(m), i.opacity = m[3] } void 0 !== h.baseColorTexture && c.push(a.assignTexture(i, "map", h.baseColorTexture)), i.metalness = void 0 !== h.metallicFactor ? h.metallicFactor : 1, i.roughness = void 0 !== h.roughnessFactor ? h.roughnessFactor : 1, void 0 !== h.metallicRoughnessTexture && (c.push(a.assignTexture(i, "metalnessMap", h.metallicRoughnessTexture)), c.push(a.assignTexture(i, "roughnessMap", h.metallicRoughnessTexture))) } !0 === o.doubleSided && (i.side = THREE.DoubleSide); var f = o.alphaMode || I; if (f === C ? (i.transparent = !0, i.depthWrite = !1) : (i.transparent = !1, f === P && (i.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && t !== THREE.MeshBasicMaterial && (c.push(a.assignTexture(i, "normalMap", o.normalTexture)), i.normalScale = new THREE.Vector2(1, 1), void 0 !== o.normalTexture.scale && i.normalScale.set(o.normalTexture.scale, o.normalTexture.scale)), void 0 !== o.occlusionTexture && t !== THREE.MeshBasicMaterial && (c.push(a.assignTexture(i, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (i.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && t !== THREE.MeshBasicMaterial && (i.emissive = (new THREE.Color).fromArray(o.emissiveFactor)), void 0 !== o.emissiveTexture && t !== THREE.MeshBasicMaterial && c.push(a.assignTexture(i, "emissiveMap", o.emissiveTexture)), l[r.KHR_MATERIALS_CLEARCOAT]) { var E = n[r.KHR_MATERIALS_CLEARCOAT]; t = E.getMaterialType(), c.push(E.extendParams(i, { extensions: l }, a)) } return Promise.all(c).then(function () { var s; return s = t === d ? n[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(i) : new t(i), o.name && (s.name = o.name), s.map && (s.map.encoding = THREE.sRGBEncoding), s.emissiveMap && (s.emissiveMap.encoding = THREE.sRGBEncoding), U(s, o), a.associations.set(s, { type: "materials", index: e }), o.extensions && N(n, s, o), s }) }, B.prototype.loadGeometries = function (e) { var t = this, a = this.extensions, s = this.primitiveCache; function n(e) { return a[r.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function (r) { return k(r, e, t) }) } for (var o, i, l = [], c = 0, u = e.length; c < u; c++) { var p, h = e[c], d = (i = void 0, (i = (o = h).extensions && o.extensions[r.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + i.bufferView + ":" + i.indices + ":" + G(i.attributes) : o.indices + ":" + G(o.attributes) + ":" + o.mode), m = s[d]; if (m) l.push(m.promise); else p = h.extensions && h.extensions[r.KHR_DRACO_MESH_COMPRESSION] ? n(h) : k(new THREE.BufferGeometry, h, t), s[d] = { primitive: h, promise: p }, l.push(p) } return Promise.all(l) }, B.prototype.loadMesh = function (e) { for (var t, r = this, a = this.json.meshes[e], s = a.primitives, n = [], o = 0, i = s.length; o < i; o++) { var l = void 0 === s[o].material ? (void 0 === (t = this.cache).DefaultMaterial && (t.DefaultMaterial = new THREE.MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: THREE.FrontSide })), t.DefaultMaterial) : this.getDependency("material", s[o].material); n.push(l) } return n.push(r.loadGeometries(s)), Promise.all(n).then(function (t) { for (var n = t.slice(0, t.length - 1), o = t[t.length - 1], i = [], l = 0, c = o.length; l < c; l++) { var u, p = o[l], h = s[l], d = n[l]; if (h.mode === M || h.mode === y || h.mode === S || void 0 === h.mode) !0 !== (u = !0 === a.isSkinnedMesh ? new THREE.SkinnedMesh(p, d) : new THREE.Mesh(p, d)).isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), h.mode === y ? u.geometry = K(u.geometry, THREE.TriangleStripDrawMode) : h.mode === S && (u.geometry = K(u.geometry, THREE.TriangleFanDrawMode)); else if (h.mode === T) u = new THREE.LineSegments(p, d); else if (h.mode === R) u = new THREE.Line(p, d); else if (h.mode === v) u = new THREE.LineLoop(p, d); else { if (h.mode !== g) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode); u = new THREE.Points(p, d) } Object.keys(u.geometry.morphAttributes).length > 0 && D(u, a), u.name = a.name || "mesh_" + e, o.length > 1 && (u.name += "_" + l), U(u, a), r.assignFinalMaterial(u), i.push(u) } if (1 === i.length) return i[0]; var m = new THREE.Group; for (l = 0, c = i.length; l < c; l++)m.add(i[l]); return m }) }, B.prototype.loadCamera = function (e) { var t, r = this.json.cameras[e], a = r[r.type]; if (a) return "perspective" === r.type ? t = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(a.yfov), a.aspectRatio || 1, a.znear || 1, a.zfar || 2e6) : "orthographic" === r.type && (t = new THREE.OrthographicCamera(-a.xmag, a.xmag, a.ymag, -a.ymag, a.znear, a.zfar)), r.name && (t.name = r.name), U(t, r), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") }, B.prototype.loadSkin = function (e) { var t = this.json.skins[e], r = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(r) : this.getDependency("accessor", t.inverseBindMatrices).then(function (e) { return r.inverseBindMatrices = e, r }) }, B.prototype.loadAnimation = function (e) { for (var t = this.json.animations[e], r = [], a = [], s = [], n = [], o = [], i = 0, l = t.channels.length; i < l; i++) { var c = t.channels[i], u = t.samplers[c.sampler], p = c.target, h = void 0 !== p.node ? p.node : p.id, d = void 0 !== t.parameters ? t.parameters[u.input] : u.input, m = void 0 !== t.parameters ? t.parameters[u.output] : u.output; r.push(this.getDependency("node", h)), a.push(this.getDependency("accessor", d)), s.push(this.getDependency("accessor", m)), n.push(u), o.push(p) } return Promise.all([Promise.all(r), Promise.all(a), Promise.all(s), Promise.all(n), Promise.all(o)]).then(function (r) { for (var a = r[0], s = r[1], n = r[2], o = r[3], i = r[4], l = [], c = 0, u = a.length; c < u; c++) { var p = a[c], h = s[c], d = n[c], m = o[c], f = i[c]; if (void 0 !== p) { var g; switch (p.updateMatrix(), p.matrixAutoUpdate = !0, w[f.path]) { case w.weights: g = THREE.NumberKeyframeTrack; break; case w.rotation: g = THREE.QuaternionKeyframeTrack; break; case w.position: case w.scale: default: g = THREE.VectorKeyframeTrack }var T = p.name ? p.name : p.uuid, v = void 0 !== m.interpolation ? b[m.interpolation] : THREE.InterpolateLinear, R = []; w[f.path] === w.weights ? p.traverse(function (e) { !0 === e.isMesh && e.morphTargetInfluences && R.push(e.name ? e.name : e.uuid) }) : R.push(T); var M = d.array; if (d.normalized) { var y; if (M.constructor === Int8Array) y = 1 / 127; else if (M.constructor === Uint8Array) y = 1 / 255; else if (M.constructor == Int16Array) y = 1 / 32767; else { if (M.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type."); y = 1 / 65535 } for (var S = new Float32Array(M.length), H = 0, L = M.length; H < L; H++)S[H] = M[H] * y; M = S } for (H = 0, L = R.length; H < L; H++) { var x = new g(R[H] + "." + w[f.path], h.array, M, v); "CUBICSPLINE" === m.interpolation && (x.createInterpolant = function (e) { return new E(this.times, this.values, this.getValueSize() / 3, e) }, x.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(x) } } } var A = t.name ? t.name : "animation_" + e; return new THREE.AnimationClip(A, void 0, l) }) }, B.prototype.loadNode = function (e) { var t, a = this.json, s = this.extensions, n = this, o = a.meshReferences, i = a.meshUses, l = a.nodes[e]; return (t = [], void 0 !== l.mesh && t.push(n.getDependency("mesh", l.mesh).then(function (e) { var t; if (o[l.mesh] > 1) { var r = i[l.mesh]++; (t = e.clone()).name += "_instance_" + r } else t = e; return void 0 !== l.weights && t.traverse(function (e) { if (e.isMesh) for (var t = 0, r = l.weights.length; t < r; t++)e.morphTargetInfluences[t] = l.weights[t] }), t })), void 0 !== l.camera && t.push(n.getDependency("camera", l.camera)), l.extensions && l.extensions[r.KHR_LIGHTS_PUNCTUAL] && void 0 !== l.extensions[r.KHR_LIGHTS_PUNCTUAL].light && t.push(n.getDependency("light", l.extensions[r.KHR_LIGHTS_PUNCTUAL].light)), Promise.all(t)).then(function (t) { var r; if ((r = !0 === l.isBone ? new THREE.Bone : t.length > 1 ? new THREE.Group : 1 === t.length ? t[0] : new THREE.Object3D) !== t[0]) for (var a = 0, o = t.length; a < o; a++)r.add(t[a]); if (l.name && (r.userData.name = l.name, r.name = THREE.PropertyBinding.sanitizeNodeName(l.name)), U(r, l), l.extensions && N(s, r, l), void 0 !== l.matrix) { var i = new THREE.Matrix4; i.fromArray(l.matrix), r.applyMatrix4(i) } else void 0 !== l.translation && r.position.fromArray(l.translation), void 0 !== l.rotation && r.quaternion.fromArray(l.rotation), void 0 !== l.scale && r.scale.fromArray(l.scale); return n.associations.set(r, { type: "nodes", index: e }), r }) }, B.prototype.loadScene = function () { function e(t, r, a, s) { var n = a.nodes[t]; return s.getDependency("node", t).then(function (e) { return void 0 === n.skin ? e : s.getDependency("skin", n.skin).then(function (e) { for (var r = [], a = 0, n = (t = e).joints.length; a < n; a++)r.push(s.getDependency("node", t.joints[a])); return Promise.all(r) }).then(function (r) { return e.traverse(function (e) { if (e.isMesh) { for (var a = [], s = [], n = 0, o = r.length; n < o; n++) { var i = r[n]; if (i) { a.push(i); var l = new THREE.Matrix4; void 0 !== t.inverseBindMatrices && l.fromArray(t.inverseBindMatrices.array, 16 * n), s.push(l) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[n]) } e.bind(new THREE.Skeleton(a, s), e.matrixWorld) } }), e }); var t }).then(function (t) { r.add(t); var o = []; if (n.children) for (var i = n.children, l = 0, c = i.length; l < c; l++) { var u = i[l]; o.push(e(u, t, a, s)) } return Promise.all(o) }) } return function (t) { var r = this.json, a = this.extensions, s = this.json.scenes[t], n = new THREE.Group; s.name && (n.name = s.name), U(n, s), s.extensions && N(a, n, s); for (var o = s.nodes || [], i = [], l = 0, c = o.length; l < c; l++)i.push(e(o[l], n, r, this)); return Promise.all(i).then(function () { return n }) } }(), e }();